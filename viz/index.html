<!DOCTYPE html>
<meta charset="utf-8">
<style>

line {
  stroke: #999;
}

circle {
  stroke: #fff;
  stroke-width: 1.5px;
}

.node text {
  pointer-events: none;
  font: 10px sans-serif;
}
#tools div { 
  display: inline;
}

form, select { 
  float: right;
  display: inline; 
}

</style>
<body>
<div id='tools'>
	<input type='checkbox' id='jesusCheckbox'>Jesus?</input>
</div>
<svg width="1000" height="1000"></svg>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
<script>

var svg = d3.select("svg"),
    width = +svg.attr("width"),
    height = +svg.attr("height");

svg.append('rect')
    .attr('width', '100%')
    .attr('height', '100%')
    .attr('fill', '#fff');

// Call zoom for svg container.
svg.call(d3.zoom().on('zoom', zoomed));

var color = d3.scaleLinear()
	.domain([1639,1649])
	.range([0.1,1]);

var simulation = d3.forceSimulation()
    .force("link", d3.forceLink().id(function(d) { return d.id; }))
    .force("charge", d3.forceManyBody().strength([-120]).distanceMax([500]))
    .force("center", d3.forceCenter(width / 2, height / 2));

var container = svg.append('g');
var link = container.append('g').selectAll('.link');
var node = container.append('g').selectAll('.node');


d3.json("1640s_dedications.json", function(error, graph) {
  if (error) throw error;

  update(graph);

  	var jesusToggle = d3.select('#jesusCheckbox')
		.on('change', function() {
			if (this.checked) {
				var newLinks = graph.links.filter(function(l) {return l.source.id != 'Jesus Christ' && l.target.id != 'Jesus Christ';});
				var newNodes = graph.nodes.filter(function(d) {return d.id != 'Jesus Christ';});
				var newGraph = {nodes:newNodes, links:newLinks};
				update(newGraph);
			}
			else {
				update(graph);
			}
		});

	// A pathDropdown menu with three different graph layouts (based on more limited subsets of nodes).
	var pathDropdown = d3.select('div#tools')
		.append('select')
		.on('change', function() { 
			var val = this.value;
			if (val == "Bipartite (Texts and People)") {
				d3.select('#jesusCheckbox').attr('disabled', 'false');
				update(graph);
			};
			if (val == "People Only") {
				d3.select('#jesusCheckbox').attr('disabled', 'true');
				var projectedPeopleGraph = project(graph, 1);
				update(projectedPeopleGraph);
			};
			if (val == "Texts Only") {
				d3.select('#jesusCheckbox').attr('disabled', 'true');
				var projectedTextGraph = project(graph, 0);
				update(projectedTextGraph);
			};

		});

	pathDropdown.selectAll('option')
		.data(['Bipartite (Texts and People)', 'People Only', 'Texts Only'])
		.enter().append('option')
		.attr('value', function(d) { return d; })
		.text(function(d) { return d; });

});

function dragstarted(d) {
  if (!d3.event.active) simulation.alphaTarget(0.3).restart();
  d.fx = d.x;
  d.fy = d.y;
}

function dragged(d) {
  d.fx = d3.event.x;
  d.fy = d3.event.y;
}

function dragended(d) {
  if (!d3.event.active) simulation.alphaTarget(0);
  d.fx = null;
  d.fy = null;
}

// Zooming function translates the size of the svg container.
function zoomed() {
	  container.attr("transform", "translate(" + d3.event.transform.x + ", " + d3.event.transform.y + ") scale(" + d3.event.transform.k + ")");
}

function project(graph, bipartite) {
	var projectedNodes = graph.nodes.filter( function(d) {return d.bipartite === bipartite;});
	var nodeObject = {}
	projectedNodes.forEach( function(d) { nodeObject[d.id] = 1; });
	var projectedLinks = [];
	graph.links.forEach(function(l){
		if (l.source.id in nodeObject) {
			graph.links.forEach(function(m) {
				if (m.source.id == l.target.id && m.target.id in nodeObject) {
					projectedLinks.push({source:l.source, target:m.target, weight:1});
				}
				else if (m.target.id == l.target.id && m.source.id in nodeObject) {
					projectedLinks.push({source:l.source, target:m.source, weight:1});
				}
			});
		}
		if (l.target.id in nodeObject) {
			graph.links.forEach(function(m) {
				if (m.source.id == l.source.id && m.target.id in nodeObject) {
					projectedLinks.push({source:l.target, target:m.target, weight:1});
				}
				else if (m.target.id == l.target.id && m.source.id in nodeObject) {
					projectedLinks.push({source:l.target, target:m.source, weight:1});
				}
			});
		}
	});
	return {nodes:projectedNodes, links:projectedLinks};
}



function update(graph) {
  // Make object of all neighboring nodes.
  var linkedByIndex = {};
  graph.links.forEach(function(d) {
	  linkedByIndex[d.source.id + ',' + d.target.id] = 1;
	  linkedByIndex[d.target.id + ',' + d.source.id] = 1;
  });

  // A function to test if two nodes are neighboring.
  function neighboring(a, b) {
	  return linkedByIndex[a.id + ',' + b.id];
  }

  // Linear scale for degree centrality.
  var degreeSize= d3.scaleLog()
  	.domain([d3.min(graph.nodes, function(d) {return d.degree; }),d3.max(graph.nodes, function(d) {return d.degree; })])
  	.range([5,20]);

  // Collision detection based on node radius.
  simulation.force("collide", d3.forceCollide().radius( 20 ) );//function(d) { return d.degree * 2; } ) );

  //var link = container.append("g")
      //.attr("class", "links")
    //.selectAll("line")
  link = link.data(graph.links, function(d) { return d.source.id + ", " + d.target.id;});

  link.exit().remove();

  link = link.enter().append("line")
      .attr('class', 'link')
      .attr('stroke-width', function(l) {return l.weight;})
      .merge(link);

  //var node = container.append("g")
      //.attr("class", "nodes")
    //.selectAll("circle")
    //.data(graph.nodes);

  node = node.data(graph.nodes, function(d) {return d.id;});
  node.exit().remove();

  node = node.enter().append("circle")
    // Calculate degree centrality within JavaScript.
    //.attr("r", function(d, i) { count = 0; graph.links.forEach(function(l) { if (l.source == i || l.target == i) { count += 1;}; }); return size(count);})
    // Size nodes, making Cavendish and Glanvill largest.
    .attr('r', function(d, i) {if (d.bipartite === 1) {return degreeSize(d.degree);} else {return 8;} })
    // Color by degree centrality calculation in NetworkX.
	    .attr("fill", function(d) {if (d.bipartite === 0) {return d3.interpolateBlues(color(d.date));} else {return 'red';} }) 
      .attr('class', 'node')
      .attr('id', function(d) { return "n" + d.id.toString(); })
      .call(d3.drag()
          .on("start", dragstarted)
          .on("drag", dragged)
          .on("end", dragended))
      .merge(node);
  

  // Title text for mouseover.
  node.append("title")
      .text(function(d) { 
	 if (d.bipartite === 1) {
	      return d.id+'\nDegree: '+d.degree+' ('+d.deg_rank+')'+'\nBetweenness Centrality: '+d.betweenness+' ('+d.betw_rank+')'+'\nCloseness Centrality: '+d.closeness+' ('+d.close_rank+')';
	 } 
	 else {
	      return 'Author: '+d.author+'\nTitle: '+d.title+'\nDate: '+d.date+'\nDegree: '+d.degree+' ('+d.deg_rank+')'+'\nBetweenness Centrality: '+d.betweenness+' ('+d.betw_rank+')'+'\nCloseness Centrality: '+d.closeness+' ('+d.close_rank+')';
	}
	});

  simulation
      .nodes(graph.nodes)
      .on("tick", ticked);

  simulation.force("link")
      .links(graph.links);

  simulation.alphaTarget(0.1).restart();

  function ticked() {
    link
        .attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; });

    node
        .attr("cx", function(d) { return d.x; })
        .attr("cy", function(d) { return d.y; });
  }

}


</script>
</body>
