<!DOCTYPE html>
<meta charset="utf-8">
<style>

.links line {
  stroke: #999;
  stroke-opacity: 0.6;
}

.nodes circle {
  stroke: #fff;
  stroke-width: 1.5px;
}

.node text {
  pointer-events: none;
  font: 10px sans-serif;
}
#tools div { 
  display: inline;
}

form, select { 
  float: right;
  display: inline; 
}

</style>
<body>
<div id='tools'></div>
<svg width="1000" height="1000"></svg>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
<script>

var svg = d3.select("svg"),
    width = +svg.attr("width"),
    height = +svg.attr("height");

svg.append('rect')
    .attr('width', '100%')
    .attr('height', '100%')
    .attr('fill', '#fff');

// Call zoom for svg container.
svg.call(d3.zoom().on('zoom', zoomed));

var color = d3.scaleOrdinal(d3.schemeCategory20);

var simulation = d3.forceSimulation()
    .force("link", d3.forceLink().id(function(d) { return d.id; }))
    .force("charge", d3.forceManyBody().strength([-120]).distanceMax([500]))
    .force("center", d3.forceCenter(width / 2, height / 2));

var container = svg.append('g');

// Create form for search (see function below).
var search = d3.select("div#tools").append('form').attr('onsubmit', 'return false;');

var box = search.append('input')
	.attr('type', 'text')
	.attr('id', 'searchTerm')
	.attr('placeholder', 'Type to search...');

var button = search.append('input')
	.attr('type', 'button')
	.attr('value', 'Search')
	.on('click', function () { searchNodes(); });

// Toggle for ego networks on click (below).
var toggle = 0;


d3.json("1640s_dedications.json", function(error, graph) {
  if (error) throw error;

  // Make object of all neighboring nodes.
  var linkedByIndex = {};
  graph.links.forEach(function(d) {
	  linkedByIndex[d.source + ',' + d.target] = 1;
	  linkedByIndex[d.target + ',' + d.source] = 1;
  });

  // A function to test if two nodes are neighboring.
  function neighboring(a, b) {
	  return linkedByIndex[a.id + ',' + b.id];
  }

  // A function to handle click toggling based on neighboring nodes.
  function toggleClick(d) {
	      if (toggle == 0) {
		      // Ternary operator restyles links and nodes if they are adjacent.
		      d3.selectAll('.link').style('stroke-opacity', function (l) {
			      return l.target == d || l.source == d ? 1 : 0.1;
		      });
		      d3.selectAll('.node').style('opacity', function (n) {
			      return neighboring(d, n) ? 1 : 0.1;
		      });
		      d3.select('#n'+d.id.toString()).style('opacity', 1);

			// Show information when node is clicked
			d3.select('div#tools').append('span').text("Name: " + d.name + "  |  Historical Significance: " + d.historical_significance + "  |  Lived: " + d.birth_year + "-" + d.death_year);
		      toggle = 1;
	      }
	      else {
		      // Restore nodes and links to normal opacity.
		      d3.selectAll('.link').style('stroke-opacity', '0.6');
		      d3.selectAll('.node').style('opacity', '1');
		      d3.selectAll('span').remove();
		      toggle = 0;
	      }
  }
  // Linear scale for degree centrality.
  var degreeSize= d3.scaleLog()
  	.domain([d3.min(graph.nodes, function(d) {return d.degree; }),d3.max(graph.nodes, function(d) {return d.degree; })])
  	.range([5,20]);

  // A function for the coloring to show how two graphs are joined.
  function colorByShared(d) {
	if (d.glanvill_two_degree == 1 && d.cavendish_two_degree == 1) { return '#7D26CD'; }
	else if (d.glanvill_two_degree == 1) { return '#FF6663'; }
	else if (d.cavendish_two_degree == 1) { return '#49B2FF'; };
  }

  // Collision detection based on node radius.
  simulation.force("collide", d3.forceCollide().radius( 20 ) );//function(d) { return d.degree * 2; } ) );

  var link = container.append("g")
      .attr("class", "links")
    .selectAll("line")
    .data(graph.links, function(d) { return d.source + ", " + d.target;})
    .enter().append("line")
      .attr('class', 'link')
      .attr('stroke-width', function(l) {return l.weight;});

  var node = container.append("g")
      .attr("class", "nodes")
    .selectAll("circle")
    .data(graph.nodes)
    .enter().append("circle")
    // Calculate degree centrality within JavaScript.
    //.attr("r", function(d, i) { count = 0; graph.links.forEach(function(l) { if (l.source == i || l.target == i) { count += 1;}; }); return size(count);})
    // Size nodes, making Cavendish and Glanvill largest.
    .attr('r', function(d, i) {if (d.bipartite === 1) {return degreeSize(d.degree);} else {return 8;} })
    // Color by degree centrality calculation in NetworkX.
	    .attr("fill", function(d) {if (d.bipartite === 0) {return 'blue';} else {return 'red';} }) 
      .attr('class', 'node')
      .attr('id', function(d) { return "n" + d.id.toString(); })
      // On click, toggle ego networks for the selected node. (See function above.)
      .on('click', function(d) { toggleClick(d); })
      .call(d3.drag()
          .on("start", dragstarted)
          .on("drag", dragged)
          .on("end", dragended));

  // Title text for mouseover.
  node.append("title")
      .text(function(d) { return d.id; });

  simulation
      .nodes(graph.nodes)
      .on("tick", ticked);

  simulation.force("link")
      .links(graph.links);

  function ticked() {
    link
        .attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; });

    node
        .attr("cx", function(d) { return d.x; })
        .attr("cy", function(d) { return d.y; });
  }

  	// A slider (using only d3 and HTML5) that removes nodes below the input threshold.
	var slider = d3.select('div#tools').append('div').text('Confidence Estimate ("All Paths" only): ');

	var sliderLabel = slider.append('label')
		.attr('for', 'threshold')
		.text('60');
	var sliderMain = slider.append('input')
		.attr('type', 'range')
		.attr('min', d3.min(graph.links, function(d) {return d.weight; }))
		.attr('max', d3.max(graph.links, function(d) {return d.weight; }) )
		.attr('value', 60)
		.attr('id', 'threshold')
		.style('width', '50%')
		.style('display', 'block')
		.on('input', function () { 
			var threshold = this.value;

			d3.select('label').text(threshold);

			// Find the links that are at or above the threshold.
			var newLinks = [];
			graph.links.forEach( function (d) {
				if (d.weight >= threshold) {
					newLinks.push(d); 
				};
			});

			// Data join with only those new links and corresponding nodes.
			link = link.data(newLinks, function(d) {return d.source + ', ' + d.target;});
			link.exit().remove();
			var linkEnter = link.enter().append('line').attr('class', 'link');
			link = linkEnter.merge(link);

			var newNodes = [];
			graph.nodes.forEach( function(d) {
				newLinks.forEach( function(l) {
					if (l.source == d || l.target == d) { newNodes.push(d); };
				});
			});

			newNodes = Array.from(new Set(newNodes));

			// When adding and removing nodes, reassert attributes and behaviors.
			node = node.data(newNodes, function(d) {return d.id;});
			node.exit().remove();
			var nodeEnter = node.enter().append('circle')
				.attr('r', function(d, i) { if (d.name == 'Margaret Cavendish' || d.name == 'Joseph Glanvill') {return 30;} else if (d.shortest_path == 1) {return 20;} else {return 10;}; })
				.attr('class', 'node')
      				.attr('id', function(d) { return "n" + d.id.toString(); })
				.attr("fill", function(d) { 
					var val = document.getElementById('color').value;
					if (val == "Color by Degree") { return d3.interpolateRdYlBu(degreeColor(d.degree)); }
					else if (val == "Color by Shared Distance") { return colorByShared(d); }
					else if (val == "Color by Minimum Node Cut") { if (d.min_node_cut == 1) { return "#BCED91"; } else { return "silver"; }; }
				})
		        .on('click', function(d, i) { toggleClick(d); })
		        .call(d3.drag()
		            .on("start", dragstarted)
		            .on("drag", dragged)
		            .on("end", dragended));
		  

			node = nodeEnter.merge(node);

		    node.append("title")
		        .text(function(d) { return d.name; });

			// Restart simulation with new node and link data.
			simulation
				.nodes(newNodes).on('tick', ticked)
				.force("link").links(newLinks, function(d) {return d.source + ', ' + d.target;});

			simulation.alphaTarget(0.1).restart();


		});

	// A pathDropdown menu with three different graph layouts (based on more limited subsets of nodes).
	var pathDropdown = d3.select('div#tools')
		.append('select')
		.on('change', function() { 
			var val = this.value;
			if (val == "All Paths") {
				var newNodes = graph.nodes;
				var newLinks = graph.links;
				sliderMain.attr('disabled', null);
			};
			if (val == "Only Direct Paths") {
				var newNodes = [];
				graph.nodes.forEach( function(d) {
					if (d.connected_path == 1) {newNodes.push(d); };
				});

				var newLinks = [];
				graph.links.forEach( function(l) {
					if (newNodes.includes(l.source) && newNodes.includes(l.target)) {
						newLinks.push(l);
					};
				});
				sliderMain.attr('disabled', 'disabled');
			};
			if (val == "Only Shortest Direct Paths") {
				var newNodes = [];
				graph.nodes.forEach( function(d) {
					if (d.shortest_path == 1) {newNodes.push(d); };
				});

				var newLinks = [];
				graph.links.forEach( function(l) {
					if (newNodes.includes(l.source) && newNodes.includes(l.target)) {
						newLinks.push(l);
					};
				});
				sliderMain.attr('disabled', 'disabled');
			};

			link = link.data(newLinks, function(d) {return d.source + ', ' + d.target;});
			link.exit().remove();
			var linkEnter = link.enter().append('line').attr('class', 'link');
			link = linkEnter.merge(link);

			node = node.data(newNodes, function(d) {return d.id;});
			node.exit().remove();
			var nodeEnter = node.enter().append('circle')
				.attr('r', function(d, i) { if (d.name == 'Margaret Cavendish' || d.name == 'Joseph Glanvill') {return 30;} else if (d.shortest_path == 1) {return 20;} else {return 10;}; })
				.attr('class', 'node')
      				.attr('id', function(d) { return "n" + d.id.toString(); })
				.attr("fill", function(d) { 
					var val = document.getElementById('color').value;
					if (val == "Color by Degree") { return d3.interpolateRdYlBu(degreeColor(d.degree)); }
					else if (val == "Color by Shared Distance") { return colorByShared(d); }
					else if (val == "Color by Minimum Node Cut") { if (d.min_node_cut == 1) { return "#BCED91"; } else { return "silver"; }; }
				})
		        .on('click', function(d, i) { toggleClick(d); })
		        .call(d3.drag()
		            .on("start", dragstarted)
		            .on("drag", dragged)
		            .on("end", dragended))
		  

			node = nodeEnter.merge(node);

		    node.append("title")
		        .text(function(d) { return d.name; });

			// Restart simulation with new node and link data.
			simulation
				.nodes(newNodes).on('tick', ticked)
				.force("link").links(newLinks, function(d) {return d.source + ', ' + d.target;});

			simulation.alphaTarget(0.1).restart();

			sliderLabel.text('60');
			document.getElementById("threshold").stepDown(40);
			
		});

	pathDropdown.selectAll('option')
		.data(['All Paths', 'Only Direct Paths', 'Only Shortest Direct Paths'])
		.enter().append('option')
		.attr('value', function(d) { return d; })
		.text(function(d) { return d; });

	// A second dropdown with three different color schemes for nodes
	var colorDropdown = d3.select('div#tools')
		.append('select')
		.attr('id', 'color')
		.on('change', function() { 
	       		var val = this.value;
			node.attr("fill", function(d) {
				if (val == "Color by Degree") { return d3.interpolateRdYlBu(degreeColor(d.degree)); }
				else if (val == "Color by Shared Distance") { return colorByShared(d); }
				else if (val == "Color by Minimum Node Cut") { if (d.min_node_cut == 1) { return "#BCED91"; } else { return "silver"; }; }
			});
		});

	colorDropdown.selectAll('option')
		.data(["Color by Degree", "Color by Shared Distance", "Color by Minimum Node Cut"])
		.enter().append('option')
		.attr('value', function(d) { return d; })
		.text(function(d) {return d;});
});

function dragstarted(d) {
  if (!d3.event.active) simulation.alphaTarget(0.3).restart();
  d.fx = d.x;
  d.fy = d.y;
}

function dragged(d) {
  d.fx = d3.event.x;
  d.fy = d3.event.y;
}

function dragended(d) {
  if (!d3.event.active) simulation.alphaTarget(0);
  d.fx = null;
  d.fy = null;
}

// Zooming function translates the size of the svg container.
function zoomed() {
	  container.attr("transform", "translate(" + d3.event.transform.x + ", " + d3.event.transform.y + ") scale(" + d3.event.transform.k + ")");
}

// Search for nodes by making all unmatched nodes temporarily transparent.
function searchNodes() {
	var term = document.getElementById('searchTerm').value;
	var selected = container.selectAll('.node').filter(function (d, i) {
		return d.name.toLowerCase().search(term.toLowerCase()) == -1;
	});
	selected.style('opacity', '0');
	var link = container.selectAll('.link');
	link.style('stroke-opacity', '0');
	d3.selectAll('.node').transition()
		.duration(5000)
		.style('opacity', '1');
	d3.selectAll('.link').transition().duration(5000).style('stroke-opacity', '0.6');
}


</script>
</body>
